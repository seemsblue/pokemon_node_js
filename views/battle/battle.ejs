<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= session.code%>번 방</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.1/font/bootstrap-icons.css">
    <link href="/css/battle.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <style>
        html,
        body {
          width: 100%;
          height: 100%;
        }
      </style>
</head>
<body>
    <div class="nav" id="en">
        <a class="jua-regular start inactive" style="font-size: large;">게임 시작!</a>
        <a class="jua-regular help" style="font-size: large;">도움말</a>
        <a class="jua-regular surrender" style="font-size: large;">항복</a>
    </div>

    <div id="resultModal" class="hidden jua-regular" style="font-size: large;">
        <div class="modal-content bg-light p-5 rounded shadow">
            <h1 id="resultText" class="mb-4"></h1>
            <p>10초 후에 매칭 페이지로 이동합니다...</p>
            <p>아무 곳이나 눌러 바로 이동</p>
        </div>
    </div>
    
    <div id="help-alt" class="alt hidden">
        <div class="alt-box">
          <button class="close-btn"><i class="bi bi-x-circle"></i></button>
          <h1 class="hyeon">도움말</h1>
          <ol class="list-group list-group-numbered">
            <li class="list-group-item d-flex justify-content-between align-items-start">
              <div class="ms-2 me-auto">
                <div class="fw-bold">포켓몬을 선택하자!</div>
                픽 단계에서 종족값과 타입 상성을 고려해 2마리의 포켓몬을 선택하세요
              </div>
              <span class="badge text-bg-primary rounded-pill">상호보완 타입을 선택하세요!</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-start">
              <div class="ms-2 me-auto">
                <div class="fw-bold">상대 포켓몬에 맞는 기술이나 교체 플레이를 하자!</div>
                만약 상대가 내 공격을 무효 타입으로 교체할 것 같다면 일반공격으로 안정된 데미지를 주는 것도 하나의 전략!
              </div>
              <span class="badge text-bg-primary rounded-pill">어려워요</span>
            </li>
            <li class="list-group-item d-flex justify-content-between align-items-start">
              <div class="ms-2 me-auto">
                <div class="fw-bold">타입별 상성 관계를 마스터하자!</div>
                실전 배틀에서 매번 위키를 찾지 않고도 타입을 떠올릴 수 있다!
              </div>
              <span class="badge text-bg-primary rounded-pill">좋아요!</span>
            </li>
          </ol>
          <br>
          <h4 class="hyeon">아무곳이나 눌러 닫을 수 있습니다...</h1>

        </div>
      </div>
    

    <div class="cover-screen" style="height: 90%; width:100%; position:relative; padding-bottom:6px;">
        <header style="height: 11%; background-color:black; position:relative;">
            <div style="height: 30%;">
                <h1 id="title" class="mb-1"><%= session.title%></h1>
                <p id="code" class="jua-regular room-code mb-1">방 번호 : <%= session.code%></>
            </div> 
            <div id="user-info" class="jua-regular d-flex flex-row" style="height: 50%; background-color:bisque; position:absolute; bottom:0px; width:100%; border:1px">
                <div id="me" class="left d-flex flex-row" style="width: 48%; height: 100%;">
                </div>
                <div class="vr" style="width: 1%;"></div>
    
                <div id="op" class="right d-flex flex-row" style="width: 48%; height: 100%;">
                    <h1>상대 기다리는중...</h1>
                </div>
            </div>
        </header>
        <div class="mt-1" id="timer" style="position:absolute; top:12%; left:5px; z-index:30;">
            <span>5</span>
        </div>

        <div class="row hidden" id="pick-screen" style="height: 70%; width:100%">
            <div class = "col-6 pick-left"></div>
            <div class = "col-6 pick-right"></div>
        </div>

        <div id="start-modal" class="start-modal hidden">
            <span id="myName1">나</span>
                <span>VS</span>
            <span id="opName1">상대</span>
        </div>

        <div class="field-container row" id="game-screen" style="height: 60%;">
            <div class="col-6 me" id="me" style="height: 90%;">
                <div class="battle-pokemon bot">
                    <img class="pokemon-img" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/back/132.png">
                    <img class="plate" src="https://raw.githubusercontent.com/seemsblue/imges/master/%EC%B4%88%EC%9B%90%EB%B0%94%EB%8B%A5.png">

                    <div class="battle-pokemon-info ">
                        <div class="name"></div>
                        <div class="hp-container">
                            <div class="hp"></div>
                            <div class="hp-text">만땅</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-6 op" id="op" style="height: 90%;">
                <div class="battle-pokemon top">
                    <img class="pokemon-img" src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/132.png">
                    <img class="plate" src="https://raw.githubusercontent.com/seemsblue/imges/master/%EC%B4%88%EC%9B%90%EB%B0%94%EB%8B%A5.png">
                    
                    <div class="battle-pokemon-info hidden">
                        <div class="name"></div>
                        <div class="hp-container">
                            <div class="hp"></div>
                            <div class="hp-text"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="message-container" class="jua-regular">
                <div id="message-box">
                    시작 준비 중
                </div>
            </div>
        </div>

        <hr class="border border-secondary border-2 opacity-75 mb-0 mt-0">


        <div class="action-btn-container position-relative" id="action-btn-container" style="height: 15%;">
            <button id="type-attack-1" class="action-btn atk-btn position-absolute top-0 start-0" data-action="typeAttack1">타입공격1</button>
            <button id="type-attack-2" class="action-btn atk-btn position-absolute top-0 end-0" data-action="typeAttack2">타입공격2</button>
            <button class="action-btn atk-btn position-absolute bottom-0 start-0" data-action="normalAttack">일반공격</button>
            <button class="action-btn change-btn position-absolute bottom-0 end-0" data-action="change">교체</button>
        </div>

        <div class="chat" style="height: 15%;">
            <div class="msg-box" style="overflow-y: scroll; height:140px">
            </div>
            <div class="input-group mb-3">
                <input type="text" class="form-control" placeholder="도발하기" aria-label="Recipient's username" aria-describedby="button-addon2" minlength="1" maxlength="21">
                <button class="btn btn-outline-secondary" type="button" id="button-addon2">Button</button>
            </div>
        </div>
    </div>
    
    
    <script src="https://cdn.jsdelivr.net/npm/socket.io@4.7.2/client-dist/socket.io.min.js"></script>

    <script>
        /** 포케 API에서 포켓몬 호출
        * 
        */
        async function getPokemonInfoById(id){   
            //서버에서는 도감번호만 보내주고, 이 작업은 클라이언트 사이드에서 해야 할지는 고민
            //서버에서 게임을 할때마다 이미지까지 다 fetch하면 너무 오래 걸리고, 클라이언트한테 종족값까지 맡기면 위조 위험이 생기는데
            //1. 사실 해결방법은 용량이 적어서 그냥 데이터베이스에 보관하면 되는데 그럼 api 써보는 의미가 없어짐
            //2. 타협해서 포켓몬 도감번호만 서버와 유저가 공유하고, 필요한 정보는 각자 불러오는데 그러면 나중에 위조검사 확장할수는 있음
            
            // 병렬로 fetch 요청
            let [response, speciesResponse, formResponse] = await Promise.all([
                fetch(`https://pokeapi.co/api/v2/pokemon/${id}`),
                fetch(`https://pokeapi.co/api/v2/pokemon-species/${id}`),
                fetch(`https://pokeapi.co/api/v2/pokemon-form/${id}`)
            ]);
            // 각 응답을 JSON으로 변환
            let data = await response.json();
            let speciesData = await speciesResponse.json();
            let formData = await formResponse.json();
        
            let jpSpecies = speciesData.names.find(i => i.language.name === "ja-Hrkt");
            let name = jpSpecies.name;
            try{
                let krSpecies = speciesData.names.find(i => i.language.name === "ko");
                name = krSpecies.name;
            }catch(e){
                console.log('포켓몬 한글이름 없는듯 '+e);
            }

            let frontImg = formData.sprites.front_default;
            let backImg;
            if(formData.sprites.back_default != null){
                backImg = formData.sprites.back_default;
            }
            else{
                console.log(name+'은 back이미지 못찾음');
                backImg = frontImg; //back은 없는 경우도 있음
            }
            
            
        
            let pokemon ={};
            pokemon.name = name; //이름(한글 우선, 없으면 일본어)
            pokemon.id = id;    //도감코드
            pokemon.types = data.types.map(typeInfo => typeInfo.type.name); //타입
            pokemon.frontImg = frontImg;
            pokemon.backImg = backImg;
            pokemon.stats = data.stats;
            let totalStat = 0;
            data.stats.map(i=> totalStat+=i.base_stat); //기타 등등 스탯 들어가있는거
            pokemon.totalStat = totalStat;  //최종 종족값

            //세부 6가지 종족값
            pokemon.hp = data.stats[0].base_stat;
            pokemon.attack = data.stats[1].base_stat;
            pokemon.defense = data.stats[2].base_stat;
            pokemon.specialAttack = data.stats[3].base_stat;
            pokemon.specialDefense = data.stats[4].base_stat;
            pokemon.speed = data.stats[5].base_stat;

            //배틀 중 사용되는 현재 능력치
            pokemon.battleAttack = pokemon.attack;
            pokemon.battleDefense = pokemon.defense;
            pokemon.battleSpecialAttack = pokemon.specialAttack;
            pokemon.battleSpecialDefense = pokemon.specialDefense;
            pokemon.battleSpeed = pokemon.speed;
            pokemon.battleAtk = Math.max(pokemon.attack, pokemon.specialAttack);    //공격 수치 = 공격과 특공 중 높은 쪽
            pokemon.battleDef = pokemon.hp + Math.max(pokemon.defense, pokemon.specialDefense); //내구도 = 체력 + 방특방 중 높은 쪽
            pokemon.battleDefMax = pokemon.battleDef;   //최대값  
            pokemon.battleDefPercent = 100;

            //console.log(pokemon);
            return pokemon;
        }

        const socket = io();

        let myName = '나';
        let opName = '상대';

        const timerSpan = document.querySelector('#timer span');
        const askStartBtn = document.getElementById('askStartBtn');
        const myGameScreen = document.querySelector('#game-screen #me');
        const opGameScreen = document.querySelector('#game-screen #op');
        const messageGameScreen = document.querySelector('#message-box');
        const btnGameScreen = document.querySelector('#action-btn-container');
        const myPokemonImg = document.querySelector('#game-screen #me .pokemon-img');
        const opPokemonImg = document.querySelector('#game-screen #op .pokemon-img');
        const myPokemonName = document.querySelector('#game-screen #me .name');
        const opPokemonName = document.querySelector('#game-screen #op .name');
        const msgBox =  document.querySelector('.msg-box');

        const battleRulePokemonCount = 2;  // 배틀 규칙에 따른 포켓몬의 개수(확장고려함?)

        let countdownInterval;
        let battleCountdownInterval;
        let side;

        let myReadyFlag = false;
        let opReadyFlag = false;
        let areBothPlayersReady = () =>{ //두 플레이어 모두 대기 상태(행동 완료 상태인지 확인)
            if(opReadyFlag==true&&myReadyFlag==true){
                return true;
            }
            return false;
        } 
        let setPlayersNotReady = ()=>{
            myReadyFlag = false;
            opReadyFlag = false;
        }

        let myDeck=[];
        let opDeck=[];
        let battleDeck = [];
        let selectFlag = false;     //포켓몬 선택 중복제출 방지
        let mySelectedPokemon = [];  //선택한 포켓몬
        let opSelectedPokemon = [];  //상대가 선택한 포켓몬
        let myFieldPokemon;  //현재 필드에 나와 있는 포켓몬
        let opFieldPokemon; 

        let myDethCount = 0;    //죽은 포켓몬 카운트
        let opDethCount = 0;

        let myFieldPokemonIndex = 0;    //현재 필드에 나와 있는 포켓몬의 내 덱에서의 인덱스 
        let opFieldPokemonIndex = 0;

        //필드 포켓몬 전환
        function changeFieldPokemon(side){ 
            if(side=='me'){
                if(myFieldPokemonIndex==0){
                    mySelectedPokemon[0] = myFieldPokemon;  // 1. 현재 필드 포켓몬의 상태를 덱에도 저장
                    myFieldPokemonIndex = 1;                // 2. 인덱스 변경
                    myFieldPokemon = mySelectedPokemon[1];  // 3. 필드 포켓몬 변경
                }
                else{
                    mySelectedPokemon[1] = myFieldPokemon;
                    myFieldPokemonIndex = 0;
                    myFieldPokemon = mySelectedPokemon[0];
                }
                
            }
            else{
                if(opFieldPokemonIndex==0){
                    opSelectedPokemon[0] = opFieldPokemon;
                    opFieldPokemonIndex = 1;
                    opFieldPokemon = opSelectedPokemon[1];
                }
                else{
                    opSelectedPokemon[1] = opFieldPokemon;
                    opFieldPokemonIndex = 0;
                    opFieldPokemon = opSelectedPokemon[0];
                }
            }
        }

        function hideGameScreen(){
            /*
            * game-screen 내의 내용물들을 숨김
            */
            myGameScreen.classList.add('hidden');
            opGameScreen.classList.add('hidden');
            messageGameScreen.classList.add('hidden');
            btnGameScreen.classList.add('hidden');
        }

        //game-screen hiddne 삭제
        function showGameScreen(){

            myGameScreen.classList.remove('hidden');
            opGameScreen.classList.remove('hidden');
            messageGameScreen.classList.remove('hidden');
            btnGameScreen.classList.remove('hidden');
            document.querySelector('.field-container #me .battle-pokemon-info').classList.remove('hidden');
            document.querySelector('.field-container #op .battle-pokemon-info').classList.remove('hidden');
        }

        function initGameScreen(){
            
        }

        //포켓몬 hp상태 업데이트 함수 (애니메이션 추가하셈)
        function updateHpInfo(){
            document.querySelector('.me .hp-text').textContent = myFieldPokemon.battleDef;
            document.querySelector('.op .hp-text').textContent = opFieldPokemon.battleDef;
            document.querySelector('#me .battle-pokemon-info .hp').style.width = `${myFieldPokemon.battleDefPercent}%`;
            document.querySelector('#op .battle-pokemon-info .hp').style.width = `${opFieldPokemon.battleDefPercent}%`;
        }
        function updateMyHpInfo(){
            document.querySelector('.me .hp-text').textContent = myFieldPokemon.battleDef;
            document.querySelector('#me .battle-pokemon-info .hp').style.width = `${myFieldPokemon.battleDefPercent}%`;
        }
        function updateOpHpInfo(){
            document.querySelector('.op .hp-text').textContent = opFieldPokemon.battleDef;
            document.querySelector('#op .battle-pokemon-info .hp').style.width = `${opFieldPokemon.battleDefPercent}%`;
        }
        function updateMyHpInfoByPercent(percent){
            document.querySelector('.me .hp-text').textContent = myFieldPokemon.battleDefMax;
            document.querySelector('#me .battle-pokemon-info .hp').style.width = `${percent}%`;
        }
        function updateOpHpInfoByPercent(percent){
            document.querySelector('.op .hp-text').textContent = opFieldPokemon.battleDefMax;
            document.querySelector('#op .battle-pokemon-info .hp').style.width = `${percent}%`;
        }

        // 이 부분을 모듈화해서 내부 텍스트 요소만 그때그때 바뀌게 해야할듯
        // 전체 리렌더
        function paintBattlePokemon(){
            document.querySelector('#game-screen #me .name').textContent = myFieldPokemon.name;
            document.querySelector('#game-screen #me .hp-container .hp').style.width = 
            `${(myFieldPokemon.battleDef / myFieldPokemon.battleDefMax)*100}%`;
            
            document.querySelector('#game-screen #me .pokemon-img').src = myFieldPokemon.backImg;
            
            document.querySelector('#game-screen #op .name').textContent = opFieldPokemon.name;
            document.querySelector('#game-screen #op .hp-container .hp').style.width = 
            `${(opFieldPokemon.battleDef / opFieldPokemon.battleDefMax)*100}%`;
            document.querySelector('#game-screen #op .pokemon-img').src = opFieldPokemon.frontImg;
        }

        function paintBattlePokemonInfo(){
            document.querySelector('#game-screen #me .name').textContent = myFieldPokemon.name;
            document.querySelector('#game-screen #me .hp-container .hp').style.width = 
            `${(myFieldPokemon.battleDef / myFieldPokemon.battleDefMax)*100}%`;

            document.querySelector('#game-screen #op .name').textContent = opFieldPokemon.name;
            document.querySelector('#game-screen #op .hp-container .hp').style.width = 
            `${(opFieldPokemon.battleDef / opFieldPokemon.battleDefMax)*100}%`;
        }

        /**
        * 공격 버튼 디자인 변경 함수
        * @param {string} type1 - (예: "fire", "water").
        * @param {string} type2 - 타입2 없으면 undifined로 임시타입 부여되고 숨겨짐
        */
        function updateAttackButtons(type1, type2) {
            const typeAttack1Button = document.getElementById('type-attack-1');
            const typeAttack2Button = document.getElementById('type-attack-2');
            const typeClasses = [
                'type-normal', 'type-fire', 'type-water', 'type-grass', 'type-electric',
                'type-ice', 'type-fighting', 'type-poison', 'type-ground', 'type-flying',
                'type-psychic', 'type-bug', 'type-rock', 'type-ghost', 'type-dragon',
                'type-dark', 'type-steel', 'type-fairy','type-undefined'
            ];
            const typeNames = { //한글 작업
                'normal': '노말 기술',
                'fire': '불꽃 기술',
                'water': '물 기술',
                'grass': '풀 기술',
                'electric': '전기 기술',
                'ice': '얼음 기술',
                'fighting': '격투 기술',
                'poison': '독 기술',
                'ground': '땅 기술',
                'flying': '비행 기술',
                'psychic': '에스퍼 기술',
                'bug': '벌레 기술',
                'rock': '바위 기술',
                'ghost': '고스트 기술',
                'dragon': '드래곤 기술',
                'dark': '악 기술',
                'steel': '강철 기술',
                'fairy': '페어리 기술',
                'undefined': '' // 두 번째 버튼을 숨길 때 사용
            };

            // 기존 타입 제거
            typeClasses.forEach(typeClass => {
                typeAttack1Button.classList.remove(typeClass);
                typeAttack2Button.classList.remove(typeClass);
            });
        
            // 타입 추가하기
            typeAttack1Button.classList.add(`type-${type1}`);
            typeAttack1Button.textContent = typeNames[type1] || '알 수 없는 기술';
            if (type2 && type2 !== 'undefined') {
                typeAttack2Button.classList.add(`type-${type2}`);
                typeAttack2Button.textContent = typeNames[type2] || '알 수 없는 기술';
                typeAttack2Button.style.display = 'inline-block';
            } else {
                typeAttack2Button.style.display = 'none'; // 타입이 없거나 undefined인 경우 숨김
            }
        }

        /**
        *   게임 종료 모달 출력 함수
        */
        function showResultModal(result){
            const resultModal = document.getElementById('resultModal');
            const resultText = document.getElementById('resultText');

            //아무곳이나 눌러 빨리 나가기 가능하게
            resultModal.addEventListener('click',function(){
                window.location.href = '/match';
            })

            //승리 메시지 출력 및 모달메시지 설정
            if (result=='win') {
                setMessage(`${opName}과(와)의 승부에서 이겼다!`);
                resultText.textContent = '승리했습니다!';
                resultText.classList.add('text-success');
            } else if(result=='lose'){
                setMessage(`${opName}과(와)의 승부에서 졌다...`);
                resultText.textContent = '패배했습니다!';
                resultText.classList.add('text-danger');
            }
            
            //3초 뒤 모달 표시
            setTimeout(()=>{
                resultModal.classList.remove('hidden');
                resultModal.classList.add('modal-overlay');
            },3000);

            // 10초 뒤에 메인 페이지로 이동 > 함수에 너무 많은 기능이 들어가는것 같으므로 분리해야할듯
            setTimeout(() => {
                window.location.href = '/match'; // 메인 페이지 URL로 변경
            }, 13000);
        }
    
        

        /**
        
        */
        function makeImgTag(url,id){
            return`<div id=${id}"><img src=${url} style="height:100%"></div>`
        }

        //게임 화면 하단 메시지 컨테이너 메시지 설정 함수
        function setMessage(message){
            document.querySelector('#message-box').innerHTML = message;
        }
        
        const maxSelection = 2;
        let selectedCount = 0;
        /**
        * 포켓몬 선택 최대 제한을 2개로 제한하는 핸들러
        */
        function handleCheckboxChange(event) {
            if (event.target.checked) {
                selectedCount++;
                if (selectedCount > maxSelection) {
                    event.target.checked = false;
                    selectedCount--;
                    alert(`You can select up to ${maxSelection} items only.`);
                }
            } else {
                selectedCount--;
            }
        }
        /**
        * indices 안에 없는 인덱스의 list 요소는 삭제하고 재할당(선택한 포켓몬만 남김)
        */
        function filterListByIndices(list, indices) {   
            return list.filter((item, index) => indices.includes(index));
        }

        let selectedItems = [0,1];
        /**
        * 포켓몬 선택 체크박스 반영 함수
        */
        function submitSelections() {
            selectedItems = [];
            document.querySelectorAll('.selection-checkbox:checked').forEach((checkbox, index) => {
                selectedItems.push(Number(checkbox.getAttribute('data-index')));    //data-index 속성 가져오기
            });
            console.log('선택함:', selectedItems);
            document.querySelector('#confirm-button').classList.add('hidden');

            // 타이머를 즉시 멈추고 리스트를 전송
            clearInterval(battleCountdownInterval);
            finalizeSelections();
        }
        //최종 전송
        function finalizeSelections() {
            if(selectFlag)return;   //중복제출 방지
            selectFlag=true;
            battleDeck = selectedItems;
            myDeck = filterListByIndices(myDeck, battleDeck);
            //console.log(myDeck);
            socket.emit('select-pokemon', myDeck); // 내 서버소켓에 선택한 포켓몬 리스트 전송
        }

        //시작버튼 클릭 이벤트
        function askStartHandler() {
            socket.emit('askStart');    //시작요청 소켓 전송
            document.querySelector('.nav .start').remove();
        } 
        
        socket.emit('ask-join','<%= JSON.stringify(session.code) %>')   //방에 들어오면 코드로 서버에 룸 접속 요청
        if('<%=side%>'=='away'){    //내 정보를 서버에 보낸다
            socket.emit('away-join',{room:'<%= JSON.stringify(session.code) %>'});
        }
        //상단 프로필 출력(홈)
        if('<%=side%>'=='home'){ //내가 홈이면
            side='home';
            console.log(myName);
            myName = "<%=home.nickname%>";
            document.querySelector('#me').innerHTML=`<div style="height:100%"><img src="<%= home.icon %>" alt="User Icon" style="height:100%;"></div><div class="col-9"><% if (home.currentIcon) { %><i class="<%= home.currentIcon %> fs-2"></i><% } %><%=home.nickname%></div>`;
            socket.emit('select-side','home');
        }
        else{
            side='away';
            opName = "<%=home.nickname%>";
            document.querySelector('#op').innerHTML =`<div style="height:100%"><img src="<%= home.icon %>" alt="User Icon" style="height:100%"></div><div class="col-9"><% if (home.currentIcon) { %><i class="<%= home.currentIcon %> fs-2"></i><% } %><%=home.nickname%></div>`
            socket.emit('select-side','away');
        }
        //어웨이 유저 접속 & 상단 프로필 출력(어웨이)
        socket.on('away-update',(away)=>{
            let iconTag = away.currentIcon || '';

            if('<%=side%>'=='away'){ //내가 어웨이면
                myName = away.nickname;
                console.log('<%=side%>');
                document.querySelector('#me').innerHTML=`<div style="height:100%"><img src="${away.icon}" alt="User Icon" style="height:100%"></div><div class="col-9"><i class="${iconTag} fs-2"></i>${myName}</div>`
            }
            else{   //내가 홈이면
                opName = away.nickname;
                document.querySelector('#op').innerHTML=`<div style="height:100%"><img src="${away.icon}" alt="User Icon" style="height:100%"></div><div class="col-9"><i class="${iconTag} fs-2"></i>${opName}</div>`
                document.querySelector('.nav .start').classList.remove('inactive');  //이제 home유저는 버튼을 클릭해 시작요청을 보낼 수 있음
                document.querySelector('.nav .start').addEventListener('click',askStartHandler);
                
            }
        })

        //askStart 수신(게임 시작 요청)
        socket.on('askStart',()=>{
            hideGameScreen();

            let counter = 6;
            document.querySelector('#timer').classList.remove('hidden'); //여기서 숨기는거 해제
            timerSpan.textContent = counter;

            countdownInterval = setInterval(() => {
                counter -= 1;
                console.log('게임 시작까지 :'+counter);
                if (counter <= -1) {
                    clearInterval(countdownInterval);
                    timerSpan.textContent = '게임중';
                    console.log('픽 시작...');
                } else {
                    timerSpan.textContent = counter;
                }
            }, 1000);
            
        });

        //배틀에 사용할 포켓몬 선택 픽 단계
        socket.on('battlePhase',()=>{
            msgBox.insertAdjacentHTML('beforeend', `<div class="chat-box ex-chat text-end"><span>2명의 포켓몬을 선택하세요!</span></div>`)
            let counter = 31;   //픽 제한시간(초)
            timerSpan.textContent = counter;
            selectFlag=false;
            myDethCount = 0;
            opDethCount = 0;

            battleCountdownInterval = setInterval(() => {
                counter -= 1;
                if (counter <= -1) {
                    clearInterval(battleCountdownInterval);
                    timerSpan.textContent = '대기중...';
                    finalizeSelections();   //선택 전송
                } else {
                    timerSpan.textContent = counter;
                }
            }, 1000); 
        })

        //덱 수신 및 포켓몬 선택창 출력
        socket.on('setDeck',async(data)=>{
            document.querySelector('.field-container').classList.add('fade-out');
            setTimeout(()=>{
                document.querySelector('.field-container').classList.add('hidden');
            },1000)

            console.log(data.homeDeck+'/'+data.awayDeck);
            let myCodes = [];
            let opCodes = [];

            if(side=='home'){
                myCodes = data.homeDeck;
                opCodes = data.awayDeck;
            }
            else{
                myCodes = data.awayDeck;
                opCodes = data.homeDeck;
            }
            myDeck = await Promise.all(myCodes.map(async i => {
                let pokemon = await getPokemonInfoById(i);
                return pokemon;
            }));
            
            opDeck = await Promise.all(opCodes.map(async i => {
                let pokemon = await getPokemonInfoById(i);
                return pokemon;
            }));
            console.log(myDeck);
            console.log(opDeck);

            async function renderDeck() {   //양 사이드의 포켓몬 덱 출력, 선택버튼 활성화
                document.querySelector('#pick-screen').classList.remove('hidden');  //hidden 제거
                await Promise.all(myDeck.map((data, i) => {
                    document.querySelector('.pick-left').insertAdjacentHTML("beforeend", `
                        <div style="height:14%; display: flex; align-items: center;">
                            ${makeImgTag(data.frontImg, i)}
                            <input type="checkbox" id="checkbox-${i}" data-index="${i}" class="selection-checkbox" onchange="handleCheckboxChange(event)">
                            <label for="checkbox-${i}" class="custom-checkbox"></label>
                        </div>
                    `);
                }));
                document.querySelector('.pick-left').insertAdjacentHTML("beforeend", `
                    <button id="confirm-button" onclick="submitSelections()">선택 완료!</button>
                `);
            }
            renderDeck();
            await Promise.all(opDeck.map((data,i)=>{
                document.querySelector('.pick-right').insertAdjacentHTML("beforeend",`<div style="height:15%">${makeImgTag(data.frontImg,i)}</div>`);
            }))
        })

        //선택된 덱 수신
        socket.on('select-pokemon',(data)=>{
            if(data.side == side){
                mySelectedPokemon = data.pokemon;
                myReadyFlag = true;
            }
            else{
                opSelectedPokemon = data.pokemon;
                opReadyFlag = true;
                console.log('상대 덱 수신');
                socket.emit('opSelect',{opPokemon:opSelectedPokemon});  //어서 달려가서 내 소켓에도 이 소식을 알리시오
            }
            myFieldPokemon = mySelectedPokemon[0];
            opFieldPokemon = opSelectedPokemon[0];
            if(areBothPlayersReady()==true){    //두명 다 선택을 마치고 기다리고 있는 상태라면 배틀 페이즈 시작 요청
                document.querySelector('.pick-left').innerHTML = '';    //픽창 지우기
                document.querySelector('.pick-right').innerHTML = '';
                document.querySelector('#pick-screen').classList.add('hidden');


                setPlayersNotReady();   //준비 상태 초기화
                hideGameScreen();
                messageGameScreen.textContent = '게임 시작 중...'
                
                showGameScreen();
                //initGameScreen();
                document.querySelector('.me .name').textContent = mySelectedPokemon[0].name;  //배틀 선봉 초기값 설정
                document.querySelector('.op .name').textContent = opSelectedPokemon[0].name;
                document.querySelector('.me .hp-text').textContent = myFieldPokemon.battleDef;
                document.querySelector('.op .hp-text').textContent = opFieldPokemon.battleDef;

                

                document.querySelector('.field-container').classList.remove('hidden');
                document.querySelector('.field-container').classList.remove('fade-out');

                //게임 시작 이펙트 애니메이션 넣을 자리
                document.querySelector('.start-modal #myName1').textContent = myName;
                document.querySelector('.start-modal #opName1').textContent = opName;
                document.getElementById('start-modal').classList.remove('hidden');
                setTimeout(()=>{
                    document.getElementById('start-modal').classList.add('fade-out');   //시작효과 사라지는 모션 시작
                    paintBattlePokemon();
                    updateAttackButtons(myFieldPokemon.types[0],myFieldPokemon.types[1]);
                    socket.emit('start-turn');
                },3000);    //3초+동안 이펙트 애니메이션 재생 (모달 형식으로 화면 다 가리면서 촤악 하면 멋질듯)
            }
        })


        /**
        * 액션 턴 페이즈
        */
        let timeInterval;   //

        function startTurn(){
            messageGameScreen.textContent = '액션을 선택하세요!'
            let counter = 31;
            timerSpan.textContent = counter;
            paintBattlePokemon();

            // 30초 카운트다운 시작
            timerInterval = setInterval(() => {
                counter--;
                timerSpan.textContent = counter;
                if(counter == 28){
                    document.getElementById('start-modal').classList.add('hidden'); //다시 시작 효과 완전 없애기
                }
                if (counter <= 0) {
                    clearInterval(timerInterval);
                    timerSpan.textContent = '통신 대기중...';

                    //플레이어의 액션이 선택되지 않은 경우 기본 액션 발동
                    if (myAction == null) myAction = 'normalAttack';
                    if (opAction == null) opAction = 'normalAttack';
                    socket.emit('send-action', { myAction: myAction, opAction: opAction });
                    myAction = null;
                    opAction = null;
                }
            }, 1000);
        }

        //소켓으로부터 턴 시작 신호 받으면 턴 시작
        socket.on('start-turn',(data)=>{
            document.querySelector('#action-btn-container').classList.remove('hidden'); //행동 선택창 활성화
            startTurn();    //턴 카운트 시작
            //기타 등등 버튼에 emit 이벤트 추가
        })

        let myAction =null;
        let opAction =null;
        //액션 선택 정보를 수신하고 2명의 액션이 선택되었다면 턴을 종료하고 서버에 결과 계산 요청 전송
        socket.on('send-action',(data)=>{
            if(data.side==side){    //내 사이드와 일치한다면 내 액션
                if(myAction!=null) return;
                myAction = data.action;
            }
            else{
                if(opAction!=null) return;
                opAction = data.action;
            }
            //console.log(myAction+'/'+opAction);
            if(myAction!=null && opAction!=null){ //내 선택과 상대 선택이 모두 null이 아니라면
                clearInterval(timerInterval); // 카운트다운 중단
                socket.emit('send-action',{myAction:myAction,opAction:opAction});
                myAction=null;
                opAction=null;
            }
        })

        /**
        * 턴 종료 결과 출력 페이즈
        * @param {objct} logLine
        */
        function printLog(logLine) {
            return new Promise((resolve) => {
                let action = logLine.action;
                if (action == 'lose' || action == 'win') {    // 승리나 패배 시 결과 모달 출력
                    setTimeout(()=>{
                        showResultModal(action);
                        resolve();  // 승리나 패배 시 즉시 resolve
                    },100)
                }
                switch (action) {    // 로그 종류별로 화면 효과 반영
                    case 'myChange': {
                        let prevName = myFieldPokemon.name; // 기존 포켓몬 이름
                        changeFieldPokemon('me');

                        /**
                        *   0. 교체 문구를 띄운다
                        *   1. img 투명도 0으로 만든다.
                        *   2. src를 바꾼다.
                        *   3. 투명도를 1로 바꾼다.
                        *   4. 교체 이름을 띄운다
                        */
                        
                        messageGameScreen.textContent = `돌아와! ${prevName}!`; // 교체 문구를 띄운다
                        myPokemonImg.style.opacity = '0';
                        setTimeout(()=>{
                            myPokemonImg.src = myFieldPokemon.backImg;  // 이미지 교체
                        },2000);
                        //두 번째 메시지 출력 및 투명도 100%로 설정
                        setTimeout(() => {
                            setMessage(`가라! ${myFieldPokemon.name}`);
                            myPokemonImg.style.opacity = '1'; // 완전히 불투명하게 설정
                        }, 3000);
                        setTimeout(() => {
                            updateMyHpInfoByPercent(100);
                            updateAttackButtons(myFieldPokemon.types[0],myFieldPokemon.types[1]);
                            myPokemonName.textContent = myFieldPokemon.name;
                            setTimeout(()=>{
                                resolve();
                            },400)
                        }, 5000); 
                        break;
                    }
                    case 'opChange': {
                        let prevName = opFieldPokemon.name; // 기존 포켓몬 이름
                        changeFieldPokemon('op');

                        messageGameScreen.textContent = `상대는 ${prevName}를 넣었다!`; // 교체 문구를 띄운다
                        opPokemonImg.style.opacity = '0';
                        setTimeout(()=>{
                            opPokemonImg.src = opFieldPokemon.frontImg;  // 이미지 교체
                        },2000);
                        // 2초 기다렸다가 두 번째 메시지 출력 및 투명도 100%로 설정
                        setTimeout(() => {
                            setMessage(`상대는 ${opFieldPokemon.name}를 내보냈다!`);
                            opPokemonImg.style.opacity = '1'; // 완전히 불투명하게 설정
                        }, 3000);
                        setTimeout(() => {
                            updateOpHpInfoByPercent(100);
                            opPokemonName.textContent = opFieldPokemon.name;
                            setTimeout(()=>{
                                resolve();
                            },400)
                        }, 5000); 
                        break;
                    }
                    case 'myAction': {
                        let atkType;
                        if (logLine.detail == 'typeAttack1') atkType = myFieldPokemon.types[0];
                        else if (logLine.detail == 'typeAttack2') atkType = myFieldPokemon.types[1];
                        else atkType = '일반';
                        
                        if (atkType==undefined) atkType = myFieldPokemon.types[0];

                        console.log(`${myFieldPokemon.name}의 ${atkType}공격!`);
                        document.querySelector('#message-box').innerHTML = `${myFieldPokemon.name}의 ${atkType}공격!`;
                        
                        // 여기에 기술 이펙트 추가
                        
                        // hp바 조정(1.5초 소모)
                        setTimeout(()=>{
                            updateOpHpInfo();   //상대 체력 조정
                        },1500)
                        
                        //console.log(`${opFieldPokemon.name} 체력 : ${opFieldPokemon.battleDefPercent}%`);

                        //효과 결과 출력(2.5초 소모)
                        setTimeout(() => {
                            if(logLine.effect =='super'){
                                messageGameScreen.textContent = `효과가 굉장했다!`;
                            }
                            else if(logLine.effect =='weak'){
                                messageGameScreen.textContent = `효과가 별로인 듯 하다...`;
                            }
                            else if(logLine.effect =='invalid'){
                                messageGameScreen.textContent = `효과가 없는 것 같다...`;
                            }
                            else{
                                messageGameScreen.textContent = ``; // 효과가 굉장 or 별로 or 스킵
                            }
                            resolve();  // 작업 완료 후 resolve 호출
                        }, 4000);

                        break;
                    }
                    case 'opAction': {
                        let atkType;
                        if (logLine.detail == 'typeAttack1') atkType = opFieldPokemon.types[0];
                        else if (logLine.detail == 'typeAttack2') atkType = opFieldPokemon.types[1];
                        else atkType = '일반';

                        if (atkType==undefined) atkType = myFieldPokemon.types[0];

                        console.log(`${opFieldPokemon.name}의 ${atkType}공격!${logLine.effect}`);
                        document.querySelector('#message-box').innerHTML = `${opFieldPokemon.name}의 ${atkType}공격!`;
                        
                        // 여기에 기술 이펙트 추가
        

                        // hp바 조정(1.5초 소모)
                        setTimeout(()=>{
                            updateMyHpInfo();   //내 체력 조정
                        },1500)
                        
                        //console.log(`${myFieldPokemon.name} 체력: ${myFieldPokemon.battleDefPercent}%`);

                        //효과 결과 출력(2.5초 소모)
                        setTimeout(() => {
                            if(logLine.effect =='super'){
                                messageGameScreen.textContent = `효과가 굉장했다!`;
                            }
                            else if(logLine.effect =='weak'){
                                messageGameScreen.textContent = `효과가 별로인 듯 하다...`;
                            }
                            else if(logLine.effect =='invalid'){
                                messageGameScreen.textContent = `효과가 없는 것 같다...`;
                            }
                            else{
                                messageGameScreen.textContent = ``; // 효과가 굉장 or 별로 or 스킵
                            }
                            resolve();  // 작업 완료 후 resolve 호출
                        }, 4000);
                        break;
                    }
                    case 'myDead': {
                        // 첫 번째 메시지 출력 및 투명도를 0으로 설정
                        setMessage(`${myFieldPokemon.name}은 쓰러졌다...`);
                        myPokemonImg.style.opacity = '0'; // 완전히 투명하게 설정

                        myDethCount++;
                        changeFieldPokemon('me');

                        if(myDethCount==battleRulePokemonCount){    //데스카운트가 게임규칙에 정해둔 수만큼 올랐다면
                            resolve();  //이후는 프린트 안하고 스킵
                        }
                        else{
                            // 1초 후에 이미지 교체(애니메이션 출력시간)
                            setTimeout(()=>{
                                myPokemonImg.src = myFieldPokemon.backImg;  // 이미지 교체
                            },1000);
                            //두 번째 메시지 출력 및 투명도 100%로 설정
                            setTimeout(() => {
                                setMessage(`가라! ${myFieldPokemon.name}`);
                                updateAttackButtons(myFieldPokemon.types[0],myFieldPokemon.types[1]);
                                myPokemonImg.style.opacity = '1'; // 완전히 불투명하게 설정
                                setTimeout(() => {
                                    resolve();
                                }, 2000); 
                            }, 2000); 
                        }
                        break;
                    }
                    case 'opDead': {
                        // 첫 번째 메시지 출력 및 투명도를 0으로 설정
                        setMessage(`${opFieldPokemon.name}은 쓰러졌다!`);
                        opPokemonImg.style.opacity = '0'; // 완전히 투명하게 설정

                        opDethCount++;
                        changeFieldPokemon('op');

                        if(opDethCount==battleRulePokemonCount){    //데스카운트가 게임규칙에 정해둔 수만큼 올랐다면
                            resolve();  //이후 프린트 안하고 스킵
                        }
                        else{
                            // 1초 후에 이미지 교체(애니메이션 출력시간)
                            setTimeout(()=>{
                                opPokemonImg.src = opFieldPokemon.frontImg;  // 이미지 교체
                            },1000);
                            // 2초 기다렸다가 두 번째 메시지 출력 및 투명도 100%로 설정
                            setTimeout(() => {
                                setMessage(`상대는 ${opFieldPokemon.name}를 내보냈다!`);
                                opPokemonImg.style.opacity = '1'; // 완전히 불투명하게 설정
                                setTimeout(() => {
                                    resolve();
                                }, 2000); 
                            }, 2000);
                        }
                        
                        break;
                    }
                    default: {
                        setTimeout(()=>{
                            resolve();  // 예기치 않은 action은 2초 후 resolve 해버리기
                        },2000);
                    }
                }
            });
        }
        
        socket.on('end-turn', async (data) => {
            let log = data.log;
            //console.log(data.log);
            mySelectedPokemon[0].battleDef = data.myPokemon[0].battleDef; // 지금은 def만 변경요소지만 추후 랭크업 다운 구현시 다른 요소도 추가 가능
            opSelectedPokemon[0].battleDef = data.opPokemon[0].battleDef;
            mySelectedPokemon[0].battleDefPercent = data.myPokemon[0].battleDefPercent;
            opSelectedPokemon[0].battleDefPercent = data.opPokemon[0].battleDefPercent;
            mySelectedPokemon[1].battleDef = data.myPokemon[1].battleDef; // 지금은 def만 변경요소지만 추후 랭크업 다운 구현시 다른 요소도 추가 가능
            opSelectedPokemon[1].battleDef = data.opPokemon[1].battleDef;
            mySelectedPokemon[1].battleDefPercent = data.myPokemon[1].battleDefPercent;
            opSelectedPokemon[1].battleDefPercent = data.opPokemon[1].battleDefPercent;
            //myFieldPokemon = mySelectedPokemon[0];
            //opFieldPokemon = opSelectedPokemon[0];
            for (let logLine of log) {
                console.log(logLine);
                await printLog(logLine); // printLog가 완료될 때까지 대기
                await new Promise(resolve => setTimeout(resolve, 1700)); // 이후에도 1초씩 간격
            }
            console.log(myFieldPokemon.name+':'+myFieldPokemon.battleDefPercent+'%');
            timerSpan.textContent = '통신 대기중...';

            updateHpInfo();
            setMessage('통신 대기중...');

            socket.emit('end-print');
        });

        //특정 플레이어가 출력을 마치고 다음 턴 시작 대기중
        socket.on('end-print',(data)=>{
            
            if(data.side == side){
                myReadyFlag = true;
            }
            else{
                opReadyFlag = true;
            }
            if(areBothPlayersReady()==true){    //두명 다 선택을 마치고 기다리고 있는 상태라면 배틀 페이즈 시작 요청
                setPlayersNotReady();
                socket.emit('start-turn');
            }
        })
        

        //상대가 게임 중 나가거나 항복했을 때
        socket.on('endGame',(data)=>{
            socket.emit('endGame',{result:data.result});
            showResultModal('win'); //이건 어차피 위조해도 점수는 서버에서 계산하고 게임 결과 관리함
        })

        //시작 전에 상대 나갔을 때
        socket.on('leave', () => {
            console.log('leave수신');   //상대가 떠나니까 엄청 많이 수신됨 원인이 뭘까
            socket.emit('leave');
            clearInterval(countdownInterval);
            timerSpan.textContent = '';
            if(side=='home'){   //홈일때(방 유지됨)
                askStartBtn.classList.add('hidden'); //시작버튼 비활성화
                askStartBtn.removeEventListener('click', askStartHandler);
            }
            else{   //어웨이일때(방 터짐)
                window.location.href = '/match';
            }
        });

        //채팅 구현
        function sendMessage(){ //채팅 전송 함수
            let msg = document.querySelector('.chat div input').value;
            if(msg.length>0){
                socket.emit('chat',{msg:msg,room:'<%= JSON.stringify(session.code) %>',side:'<%=side%>'})    //해당 방 룸의 코드로 chat 요청을 보낸다
            }
            document.querySelector('.chat div input').value='';
        };
        document.querySelector('.chat div button').addEventListener('click',sendMessage);   //클릭으로 전송
        document.querySelector('.chat .form-control').addEventListener('keydown', function(event) {   //엔터로 전송
            if (event.key === 'Enter') {
                event.preventDefault(); // 기본 Enter 동작 방지 (폼 제출 방지랑 줄바꿈 등)
                sendMessage();
            }
        });
        socket.on('chat-cast',(data)=>{
            if(data.side=='<%=side%>'){ //내 side와 메시지의 side가 같다면 왼쪽정렬
                msgBox.insertAdjacentHTML('beforeend', `<div class="chat-box my-chat"><span>${data.msg}</span></div>`)
            }
            else{
                msgBox.insertAdjacentHTML('beforeend', `<div class="chat-box op-chat text-end"><span>${data.msg}</span></div>`) 
            }
            msgBox.scrollTop = msgBox.scrollHeight;
        })

        //어떠한 이유로 인해 모든걸 중단하고 매칭 페이지로 이동해야 하는 경우
        socket.on('load-match',()=>{
            window.location.href = '/match';
        })

        //페이지 최초 로드 시 버튼에 이벤트 추가하는 이벤트들
            //교체 등 상황에 따라서 작동 방식이 아예 다른 버튼도 있으니 그냥 하나씩 달아도 될 것 같음
        document.querySelectorAll('#action-btn-container .atk-btn').forEach(button => {
            button.addEventListener('click', function() {
                // data-action 속성에 따라 socket.emit 호출
                setMessage('상대를 기다리는 중...');
                const action = this.getAttribute('data-action');    //버튼에 달려있는 속성 추출
                socket.emit('select-action', { side : side ,action : action });
                // div 컨테이너에 hidden 클래스를 추가
                document.getElementById('action-btn-container').classList.add('hidden');
            });
        });

        //교체 버튼은 따로 관리
        document.querySelector('#action-btn-container .change-btn').addEventListener('click',function(){
            if(myDethCount<1){  //교체 가능한 포켓몬이 있을 때만 요청 전송
                setMessage('상대를 기다리는 중...');

                const action = this.getAttribute('data-action');    //버튼에 달려있는 속성 추출
                socket.emit('select-action', { side : side ,action : action });
                document.getElementById('action-btn-container').classList.add('hidden');
            }
            else{
                setMessage('교체할 수 있는 포켓몬이 없다!')
            }
        })

        //상단 항복/도움말 관련 이벤트 추가
        document.querySelector(".help").addEventListener('click',function(){
            document.querySelector("#help-alt").classList.remove("hidden");
        })
        
        document.querySelector("#help-alt .close-btn").addEventListener('click',function(){
            document.querySelector("#help-alt").classList.add("hidden");
        })

        document.querySelector(".surrender").addEventListener('click',function(){
            socket.disconnect();    //연결 끊고
            showResultModal('lose');    //패배 모달출력
            timerSpan.classList.add('hidden');
        })
        document.querySelector("#help-alt").addEventListener('click',function(){
            document.querySelector("#help-alt").classList.add("hidden");
        })
    </script>
</body>
</html>